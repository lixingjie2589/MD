# 多线程

**Java.Thread**

## 概述

多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。

## 进程（process）、 线程（thread）

**进程：**

是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空 间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

**线程：**

是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。

## 线程创建

### 继承Thread类

### 实现Runnable接口

### 实现Callable接口

## 函数型接口、断定型接口

## Stream 流

## ForkJoin

工作窃取，双端队列

## 异步回调

## Volatile

- 保证可见性

- 不保证原子性

  > 指令重排 你写的程序,计算机并不是按照你写的那样去执行的。

源代码-->编译器优化的重排- ->指令并行也可能会重排->内存系统也会重排-->执行

Volatile是可以保持可观性。不能保证原子性,由于内存屏障,可以保证避免指令重排的现象产生!

在单列模式使用内存屏障

## CAS

CAS :比较当前工作内存中的值和主内存中的值,如果这个值是期望的,那么则执行操作!如果不是就一直循环!

缺点:
1、 循环会耗时
2、一次性只能保证一个共享变量的原子性
3、ABA问题

## 锁

> 公平锁、非公平锁

>可重入锁

> 自旋锁

> 死锁

死锁解决：

1.日志

2.堆栈

3.使用`jsp -l`定位进程号

4.使用`jstack 进程号`找到死锁问题